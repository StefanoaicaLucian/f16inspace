\section{The Basic Structure of Particle Systems}
From an object-oriented programming point of view a \textbf{particle system} is a simple container object which manages all the \textbf{particles} inside it. At first the container is completely empty. The container then starts adding a constant or variable number of particles per frame to itself. This container has an interface which can be used by programmers to control the particles inside it and also some properties of the container itself. But how does one design and implement such a container?\\

Here are three short steps which can be carried out in order to obtain an object-oriented model of the problem:
\begin{enumerate}
	\item In order to highlight some of the base components of an object-oriented system write down a detailed description of the problem which the system is supposed to solve.
	
	\item Iterate through the description and identify all the nouns, adjectives and verbs. The nouns represent potential class names, the verbs represent potential class attributes and the verbs represent potential class methods.
	
	\item Assign attributes and methods to classes.
\end{enumerate}

Following is a description of a particle based graphical effect.

\newpage

Let us assume that we are asked to implement multiple particle effects using particle systems. Some particles may react to external forces in a different manner than others. For example some particles can be affected by gravity while others can not. Other particles can have a very high mass making their trajectory only slightly modifiable by an external wind force. Every particle should have a trajectory weather it is influenced by an external force or not.\\

Some particle systems may emit more than one type of particles. For example a particle system which simulates the explosion of a nuclear bomb should emit both lightweight and heavy particles. The heavy particles will fall down to the ground while the lightweight particles will form a cloud of fire, smoke and dust. The fire will burn out but the smoke and dust will get carried away by external wind forces if they exist.\\

A few basic components can be easily identified in the above problem description. This components are actually classes and they can be named as follows:

\begin{itemize}
	\item Particle
	\item FireParticle
	\item SmokeParticle
	\item DustParticle
	\item ParticleSystem
	\item FireSystem
	\item SmokeSystem
	\item DustSystem
\end{itemize}

No matter how high is the difference between a particle system and another one there will still be state and behavior which is common to all particle systems. The same statement is valid for the Particle classes as well. The Particle class should be a class which the other particle classes (FireParticle, SmokeParticle, etc...) can use to inherit common functionality from. The ParticleSystem class should be
the class which holds the functionality common to all the particle system classes (FireSystem, SmokeSystem, etc...). But this is just a simple class structure which can be used to model particle systems. What is the actual mechanism which makes particle systems work? These steps are executed whenever most particle systems get rendered on a screen:

\begin{enumerate}
	\item New particles are created in order to be added to the particle system which is initially completely empty.
	\item All the attributes of the newly created particles are initialized.
	\item The list of particles contained by the particle systems is scanned for dead particles in order to remove them from the list.
	\item All the particles which still exist in the system will be moved to their new position. Each new position is computed with respect to the particles old position and attributes like direction, speed and acceleration.
	\item Finally an image of the particle system is rendered on the screen.
\end{enumerate}

Each step is described in a more detailed manner in the following subsections.

\newpage
\subsection{The Particle Spawning Step}
This is the first step in the rendering process of a particle system. This is when new particles are born. The number of particles generated per frame can contribute to the visual quality of a particle system. For example a real burning flame will not always have the same intensity meaning that it will not generate a constant number of fire particles. Using some kind of stochastic process to compute the number of particles generated per frame may make a simulated flame look more real, but for simplicity one can easily set the number of particles generated per frame to be constant.\\

One good example of a stochastic method which can be used to compute the number of particles generated per frame is to use a mean and a variance counter. The mean counter represents the average number of particles generated throughout a sequence of frames and the variance counter represents the largest possible difference between the average and the actual number of particles generated per one frame. The following formula shows exactly how this is supposed to work:
\begin{center}
	$n = m + r \cdot v$,
\end{center}
where $n$ is the number of particles generated per frame, $m$ is the mean, $v$ is the variance and $r$ is a random number between $-1$ and $1$.\\

Depending on the number of particles generated per frame, the memory consumption of particle systems can be quite high. Fortunately there is a method which can sometimes reduce their memory consumption. This method requires the inclusion of the screen area covered by the particle system in the equation. In other words if a particle system is very far away from the camera then it will appear to be very small thus a smaller number of particles will not affect the quality of the rendered image. There is no need to use $100,000$ particles to render a particle system which takes only 1 to 2 squared centimeters of the screen. The formula looks as follows:
\begin{center}
	$n = (m + r \cdot v) \cdot s$,
\end{center}
where $n$ is the number of particles generated, $m$ is the average number of particles generated over a period of time, $v$ is the variance, $r$ is a random number between $-1$ and $1$ and $s$ represents the screen area covered by the particle system.\\

\newpage
\subsection{Some Basic Particle Attributes}
While from a physics point of view a particle can be anything from a photon to a few water molecules or a even star, from an object oriented programming point of view a particle is a simple object which has a state and a behavior. The attributes of a particle represent its state and the methods of a particle represent a way to control its state. A particle can have, more or less, the following attributes: an initial position, an initial speed, an initial acceleration, an initial size, an initial color and a lifetime. The lifetime can be used as a transparency attribute as well. As the lifetime of a particle decreases its transparency increases, thus by the time a particle dies it should already be completely transparent (invisible).\\

A particle texture attribute can also be added to this basic attributes. Actually, in order to improve the visual aspects of the particle system, a whole list of texture objects can be used. By using this method a particle can be implemented to have a variety of textures throughout its lifetime. The same technique can be used for the shape and color of a particle such that the particle can have a whole range of colors and shapes throughout its lifetime.\\

The attributes of a particle can be initialized using methods similar to the ones used to compute the number of particles created per frame. For example the initial speed can be computed using the following formula: s = m + rv where s is the computed speed, m is the average of the speed values over a period of time, r is a random number between -1 and 1 and v is the maximum difference between the average speed and the actual speed of a particle. Nearly all the other particle attributes can be initialized using this technique.\\

\newpage
\subsection{What Makes a Particle Dynamic}
Any particle that changes its state (if it moves, if it changes its color, its texture or any attribute whatsoever) is dynamic. A particle which keeps its state constant during its whole lifetime is a static particle. But how to make a particle move or change its color or its transparency?\\

In order to change a particles position in three dimensional space one must add the speed vector to the old position vector. This is how the new position vector is obtained. This computation is performed with each frame. This is the basic particle movement mechanism. One could add other force vectors (gravity and wind are two good examples) to the position vector to make the movement of the particle more complex.\\

\newpage
\subsection{When to Kill a Particle}
There are a few methods which can be used to determine when to destroy particles from a system. One of these methods is to keep track of a lifetime value which is supposed to drop with each rendered frame. The distance between a particles current position and the origin of the particle system can also be used to determine when a particle leaves a certain region surrounding the origin of the system. If that distance exceeds a certain value, the particle will be removed from the particle system.\\

With each frame that is rendered on the screen, all the particles from a specific particle system are checked to see if they satisfy their dying condition satisfied. All the particles which satisfy that condition are sequentially removed from the system.

\newpage
\subsection{The Particle Rendering Process}
There are more than one methods which can be used to render particles. The particles which formed the Genesis Effect from Star Trek II: The Wrath of Khan implemented by William T. Reeves and a team of computer graphics developers were actually light sources which combined themselves with each other in an additive manner regarding their color and transparency values. This technique removed the hidden surface problem because the particles did not obscure each other but simply added more light to a certain pixel.\\

A second method would be to use billboards to represent particles. A simple rectangle made out of two simple triangles can be a billboard. In fact any two dimensional element rendered in a there dimensional environment can be a billboard. The main difference between billboards and simple triangles is that a billboard always rotates itself around one or more axes in order to face the camera. There are advantages and disadvantages to using billboards instead of light sources. One advantage is that billboards can be textured with more than one texture over their lifetime. A disadvantage is that billboards may need to be decreasingly sorted according to their distance from the camera. In other words the billboards which are furthest from the camera need to be rendered before the billboards which are closer to the camera otherwise the blending effect will be spoiled.\\